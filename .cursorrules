# Cursorルール - しかくまるプロジェクト

## ファイル修正・作成のルール

ファイルを修正または新規作成する際は、以下のルールに従ってください：
1. 修正/作成の前にその内容を端的に説明してください
2. 修正後はどのような変更を行ったかを簡潔に要約してください
3. Cursor AIを利用する場合は、具体的な指示を与えてください
4. コードレビューコメントは必ず対応または議論してください

## Cursor特有の開発プラクティス
1. AIアシスタントの活用
   - 複雑なロジックの実装前に説明を求める
   - コードレビューや最適化の提案を受ける
   - テストケース生成の補助として活用する

2. ペアプログラミング
   - Cursorの共同編集機能を活用する
   - コードの意図を明確にコメントする
   - 他者が理解しやすい変数名・関数名を使用する

3. リファクタリング
   - Cursorの自動リファクタリング機能を積極的に活用する
   - 類似コードの統合はAIに提案を求める
   - リファクタリング前後でテストが通ることを確認する

## 作業開始準備

`git status` で現在の git のコンテキストを確認します。
もし指示された内容と無関係な変更が多い場合、現在の変更からユーザーに別のタスクとして開始するように提案してください。

原則として依存関係のバージョン指定は最新のものを優先してください。

無視するように言われた場合は、そのまま続行します。

## コーディングプラクティス・開発プロセスのルール
- いついかなる時も以下の原則に必ず従って開発を進めること

### エヴァンスのDDD
- ユビキタス言語：共通言語の確立
- バウンデッドコンテキスト：境界の明確化
- エンティティ/値オブジェクト：識別性vs属性性
- 集約：整合性単位の設定
- その他、エヴァンスによるDDDのプラクティスに従う

### ベックのTDD
- Red-Green-Refactor：失敗→成功→改善
- 常に実装前にテストを作成：設計の指針
- 小さな検証サイクル：即時フィードバック
- 回帰防止：変更の安全性確保
- ベックによるTDDのプラクティスに従う

### ファウラーの思想
- リファクタリング：動作維持での構造改善
- コードスメル：問題兆候の検知
- CI/CD：継続的な統合と配信
- 進化的アーキテクチャ：変化への適応
- その他、ファウラーによるプラクティスに従う

### 関数型プログラミング
- 純粋関数：予測可能な結果
- 不変性：副作用の排除
- 高階関数：関数を値として扱う
- 宣言的プログラミング：意図の明確化
- 型安全性の確保
- その他、関数型プログラミングのプラクティスに従う

### しかくまるプロジェクト特有のルール
- LLM APIの利用は必ず抽象化レイヤーを通して行う
- 資格情報は常に暗号化して扱う
- 検索結果のキャッシュ機構を実装する
- Ankiフォーマットの厳密な検証を行う
- ユーザー入力の検証は必ず行う
- エラーハンドリングは詳細に実装する

{
  "projectName": "しかくまる",
  "description": "資格試験対策のための自動問題生成システム",

  "developmentGuidelines": {
    "fileModificationRules": [
      "修正/作成の前にその内容を端的に説明してください",
      "修正後はどのような変更を行ったかを簡潔に要約してください",
      "Cursor AIを利用する場合は、具体的な指示を与えてください",
      "コードレビューコメントは必ず対応または議論してください"
    ],

    "cursorSpecificPractices": {
      "aiAssistantUsage": [
        "複雑なロジックの実装前に説明を求める",
        "コードレビューや最適化の提案を受ける",
        "テストケース生成の補助として活用する"
      ],
      "pairProgramming": [
        "Cursorの共同編集機能を活用する",
        "コードの意図を明確にコメントする",
        "他者が理解しやすい変数名・関数名を使用する"
      ],
      "refactoring": [
        "Cursorの自動リファクタリング機能を積極的に活用する",
        "類似コードの統合はAIに提案を求める",
        "リファクタリング前後でテストが通ることを確認する"
      ]
    },

    "workStartPreparation": [
      "git statusで現在のgitコンテキストを確認する",
      "依存関係のバージョン指定は最新のものを優先する"
    ],

    "codingPractices": {
      "ddd": {
        "description": "エヴァンスのDDDプラクティス",
        "principles": [
          "ユビキタス言語：共通言語の確立",
          "バウンデッドコンテキスト：境界の明確化",
          "エンティティ/値オブジェクト：識別性vs属性性",
          "集約：整合性単位の設定"
        ]
      },
      "tdd": {
        "description": "ベックのTDDプラクティス",
        "principles": [
          "Red-Green-Refactor：失敗→成功→改善",
          "常に実装前にテストを作成：設計の指針",
          "小さな検証サイクル：即時フィードバック",
          "回帰防止：変更の安全性確保"
        ]
      },
      "fowler": {
        "description": "ファウラーの思想",
        "principles": [
          "リファクタリング：動作維持での構造改善",
          "コードスメル：問題兆候の検知",
          "CI/CD：継続的な統合と配信",
          "進化的アーキテクチャ：変化への適応"
        ]
      },
      "functionalProgramming": {
        "description": "関数型プログラミング",
        "principles": [
          "純粋関数：予測可能な結果",
          "不変性：副作用の排除",
          "高階関数：関数を値として扱う",
          "宣言的プログラミング：意図の明確化",
          "型安全性の確保"
        ]
      },
      "pythonTyping": {
        "description": "Pythonでの型注釈の徹底",
        "principles": [
          "すべての関数に対して引数と戻り値の型注釈を必ず記述する",
          "mypy, Pylance, Pyrightなどの型チェッカーを利用する",
          "from __future__ import annotationsを使用して型注釈の前方参照を可能にする",
          "Optionalやジェネリック型など高度な型注釈を適切に使用する",
          "stub (.pyi) ファイルを必要に応じて作成する",
          "TypedDictやProtocolなど厳密な型定義を活用する"
        ]
      }
    }
  },

  "projectSpecificRules": {
    "apis": {
      "llm": {
        "implementation": "必ず抽象化レイヤーを通して利用する",
        "preferredProviders": ["未定"],
        "defaultParameters": {
          "temperature": 0.7,
          "maxTokens": 2000
        }
      },
      "search": {
        "implementation": "検索結果はキャッシュ機構を実装する",
        "preferredProviders": ["未定"]
      }
    },
    "security": {
      "credentials": "常に暗号化して扱う",
      "userInput": "必ず検証を行う"
    },
    "outputFormat": {
      "anki": {
        "validation": "厳密な検証を行う",
        "structure": {
          "front": "問題文",
          "back": "解答",
          "tags": ["資格名", "トピック", "難易度"]
        }
      }
    },
    "errorHandling": "詳細に実装する"
  },

  "techStack": {
    "backend": "Python 3.11+",
    "pythonLibraries": {
      "web": "FastAPI 0.100+",
      "async": "asyncio, httpx",
      "llm": "langchain, openai",
      "search": "googlesearch-python",
      "validation": "pydantic v2",
      "testing": "pytest, hypothesis",
      "typeChecking": "mypy, pyright",
      "caching": "redis, diskcache",
      "security": "cryptography, python-jose"
    },
    "database": "SQLite/JSON",
    "testing": "pytest, hypothesis",
    "cicd": "GitHub Actions"
  },

  "codePatterns": {
    "llmApiCall": {
      "description": "LLM APIを呼び出すパターン",
      "example": "async def call_llm(prompt: str, params: Optional[Dict[str, Any]] = None) -> str:\n    client = get_llm_client()\n    try:\n        return await client.complete(prompt, params or {})\n    except Exception as e:\n        logger.error(f\"LLM API error: {e}\")\n        raise LLMException(f\"API呼び出しエラー: {e}\")"
    },
    "ankiCardGeneration": {
      "description": "Ankiカード生成パターン",
      "example": "def generate_anki_card(question: str, answer: str, tags: List[str]) -> Dict[str, Any]:\n    card: Dict[str, Any] = {\n        \"front\": question,\n        \"back\": answer,\n        \"tags\": tags\n    }\n    validate_anki_card(card)\n    return card"
    },
    "errorHandling": {
      "description": "エラーハンドリングパターン",
      "example": "try:\n    result = process_data(input_data)\nexcept ValidationError as e:\n    logger.warning(f\"入力検証エラー: {e}\")\n    return {\"status\": \"error\", \"message\": str(e)}\nexcept Exception as e:\n    logger.error(f\"予期せぬエラー: {e}\", exc_info=True)\n    return {\"status\": \"error\", \"message\": \"システムエラーが発生しました\"}"
    },
    "typedFunction": {
      "description": "型注釈を徹底した関数定義パターン",
      "example": "from typing import Dict, List, Optional, TypedDict, Union, Any\nfrom dataclasses import dataclass\n\nclass QuestionMetadata(TypedDict):\n    difficulty: str\n    topics: List[str]\n    source: Optional[str]\n\n@dataclass\nclass Question:\n    text: str\n    answer: str\n    metadata: QuestionMetadata\n\ndef analyze_question(question: Question) -> Dict[str, Any]:\n    \"\"\"質問を分析し、関連情報を返す\n\n    Args:\n        question: 分析する質問オブジェクト\n\n    Returns:\n        分析結果を含む辞書\n    \"\"\"\n    result: Dict[str, Any] = {}\n    # 実装\n    return result"
    }
  },

  "projectStructure": {
    "app": {
      "description": "メインアプリケーション",
      "modules": {
        "core": ["input_processor.py", "scope_extractor.py", "topic_analyzer.py", "question_generator.py", "quality_checker.py"],
        "llm": ["api_client.py", "analysis.py"],
        "search": ["api_client.py"],
        "output": ["anki_converter.py"]
      }
    },
    "tests": {
      "description": "テスト",
      "modules": ["test_core.py", "test_llm.py", "test_output.py"]
    }
  }
}